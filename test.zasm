

//entrypoint procedure
//points the vm to main
export main:
    //alloc "hello, world";
    move a0, 10;
    extcall 4; //alloc(10)

    move c0, a7;

message: "hello, world";

    write8 c0, 'h';
    iadd c0, 1, c0;
    write8 c0, 'e';
    iadd c0, 1, c0;
    write8 c0, 'l';
    iadd c0, 1, c0;
    write8 c0, 'l';
    iadd c0, 1, c0;
    write8 c0, 'o';
    iadd c0, 1, c0;

    move a0, a7;
    move a1, 5;
    extcall 3; //puts(a0[0..a1])

    return;

    iadd 3, 5, c0;
    isub c0, 3, c1;

    move a0, 3;
    move a1, 6;
    call sub;
    move a6, a7;

    move c0, 0b00000100;
    move c1, 0b00000010;
    bor c0, c1, c2;
    band c0, 0, c1;

    //call recurse;
    /* nested comment /* sussy /* hella bukky */ wussy */ lol */
    imp3;
    imp2;

    //zyteware::syscall
    imp3 0x07;

    /*
        /*
        //hello, world
        //lovely
        //jubbly
        */
    */

    //push 3 values to the data stack
    //stack is 8 byte aligned
    push 10;
    push 11;
    push 22;

    move c0, 10, c0;
    iadd c0, -5, c0;
    isub c0, 0x05, c0;

    jump panic;

    move a0, 0x00;

    return;

/*
export proc main /* entry point function */ { 
    iadd a0, a1, a7; //lol this is funny
    isub a0, 3, a1;

    move a1, 1; //stdout
    move a2, c0; //ptr
    move a3, 200; //len
    call write;

    move a0, 0;
    call a0, write;

    switch: {
        imul a0, 8, a0;
        iadd &switch_table, a0, c0;
        sload c0, c1;
        jump c1;

        var switch_table = v64[case0, case1, default];
        var bytes = v8[0] * 2048;

        case0: {
            iadd c0, a1, a2;
            jump switch_end;
        }
        case1: {
            isub c0, a1, a2;
            jump switch_end;
        }
        default: {
            jump switch_end;
        }
        switch_end: nullop;
    }

    if: /* a0 == 0 */ {
        
    } 
    else: {

    }

    loop: {
        jump loop;
    }

    //for (i64 a = 0; a < 100; a += 1)
    loop: {
        neql c0, 100, c1;
        iadd c0, 1, c0;
        jumpif c1, loop;
    };

    jumpif a0, ret;
    if: /* (x == 0) */
        call sub;
        return;
    ret:
        push 0x00;
        call proc_exit;
}
*/

sub: 
    isub a0, a1, a7;
    return;

recurse:
    call recurse;
    return;

//terminates execution
panic: 
    move a7, 69;
    isub a7, 3, a7;
    idiv a7, 2, a7;
    nullop;

    //unreachable;
    read8 c0, 2299998;
    read8 c1, 2299999;
    read8 c2, 2300000;
    move c0, '0';
    write8 0x00, '0'; //*null = '0';

    return;
