const std = @import("std");
const zyte = @import("zyte");
const IR = @import("IR.zig");

pub const Instruction = struct 
{
    opcode: zyte.Vm.OpCode,
    operands: []Operand,

    pub const Operand = union(enum)
    {
        empty,
        register: u4,
        immediate: u64,
        symbol: u32,
    };
};

pub const Procedure = struct 
{
    ir_statement: u32,
    entry_point: u32,
};

pub fn generateProcedure(
    allocator: std.mem.Allocator, 
    ir: IR, instructions: *std.ArrayListUnmanaged(Instruction), 
    entry_point: usize,
    procedure_queue: *std.ArrayListUnmanaged(Procedure),
    ) !void
{
    std.debug.print("\n", .{});
    std.log.info("Procedure: \n", .{});

    const procedure_queue_start = procedure_queue.items.len;

    {    
        var i: usize = entry_point;

        while (i < ir.statements.items.len)
        {
            const statement = ir.statements.items[i];

            switch (statement)
            {
                .procedure_begin => {
                    i += 1;
                },
                .procedure_end => {
                    //we should determine the next procedures in the call graph
                    //this will leave non-entrypoint procedures ungenerated
                    break;
                },
                .entry_block_begin => {
                    i += 1;
                },
                .entry_block_end => |entry_block_end| {
                    if (entry_block_end.next) |next|
                    {
                        i = next;
                    }
                    else unreachable; //entry blocks should always point to either an exit or basic block
                },
                .basic_block_begin => {
                    i += 1;
                },
                .basic_block_end => |basic_block_end| {
                    if (basic_block_end.next) |next|
                    {
                        i = next;
                    }
                    else unreachable; //entry blocks should always point to either an exit or basic block
                },
                .exit_block_begin => {
                    i += 1;
                },
                .exit_block_end => {
                    break;
                },
                .instruction => |instruction| {
                    switch (instruction.operation)
                    {
                        .call => {
                            switch (instruction.operands[0])
                            {
                                .symbol => |symbol| {
                                    const procedure_symbol = ir.symbol_table.items[symbol];

                                    var already_generated: bool = block: {
                                        for (procedure_queue.items) |procedure|
                                        {
                                            if (procedure.ir_statement == procedure_symbol.procedure_index)
                                            {
                                                break: block true;
                                            }
                                        }

                                        break: block false;
                                    };

                                    if (!already_generated)
                                    {
                                        try procedure_queue.append(allocator, .{
                                            .ir_statement = procedure_symbol.procedure_index,
                                            .entry_point = 0,
                                        });
                                    }
                                },
                                else => {},
                            }
                        },
                        else => {},
                    }

                    //we must do instruction selection first, then emit CodeGenIR instruction(s)
                    std.log.info("Generated bytecode instruction {s}", .{ @tagName(instruction.operation) });

                    i += 1;
                },
            }
        }
    }

    for (procedure_queue.items[procedure_queue_start..]) |procedure|
    {
        try generateProcedure(allocator, ir, instructions, procedure.ir_statement, procedure_queue);
    }
}

pub fn generate(allocator: std.mem.Allocator, ir: IR) !zyte.Module 
{
    var instructions = std.ArrayListUnmanaged(Instruction) {};
    defer instructions.deinit(allocator);

    //queue of procedures to be generated
    var procedure_queue = std.ArrayListUnmanaged(Procedure) {};
    defer procedure_queue.deinit(allocator);

    for (ir.entry_points.items) |entry_point|
    {
        std.log.info("Entry point index: {}", .{ entry_point });

        try generateProcedure(allocator, ir, &instructions, entry_point, &procedure_queue);
    }

    var module = zyte.Module {
        .allocator = allocator,
        .sections = .{},
        .sections_content = .{},
    };

    return module;
}